import array
import time
import deepcraft_model as m
from machine import I2C, Pin
import bmi270
import configuration as cfg

# --- Initialisierung ---

# DeepCraft AI Modell Setup
model = m.DEEPCRAFT()
model.init()
output_dim = model.get_model_output_dim()
input_dim = model.get_model_input_dim()
output_buffer = array.array('f', [0.0] * output_dim)
input_buffer = array.array('f', [0.0] * input_dim)

# IMU (BMI270) Setup
# Nutzt die Pins aus deiner configuration.py
i2c = I2C(id=0, scl=Pin(cfg.I2C_SCL), sda=Pin(cfg.I2C_SDA))
bmi = bmi270.BMI270(i2c)

# Timing & State Variablen
next_tick = time.ticks_ms()
last_heartbeat = time.ticks_ms()
last_label_idx = -1  # Speichert die letzte erkannte Geste für die "New Index" Logik

print("--- System gestartet. Warte auf Gesten (50Hz) ---")
print(f"Threshold: {cfg.GESTURE_THRESHOLD * 100:.0f}%")

# --- Main Loop ---
while True:
    # 1. Sensordaten lesen
    ax, ay, az = bmi.accel()
    gx, gy, gz = bmi.gyro()
    
    # 2. Input-Buffer für das Modell befüllen
    input_buffer[0], input_buffer[1], input_buffer[2] = ax, ay, az
    input_buffer[3], input_buffer[4], input_buffer[5] = gx, gy, gz
    
    # Daten in das Modell einspeisen
    if model.enqueue(input_buffer) == -1:
        print("Fehler: Modell-Enqueue fehlgeschlagen")
    
    # 3. Modell-Ausgabe verarbeiten
    if model.dequeue(output_buffer) == 0:
        score = max(output_buffer)
        # Array in Liste umwandeln, um .index() nutzen zu können
        current_idx = list(output_buffer).index(score)
        
        # Diagnose: Alle 3 Sekunden ein Lebenszeichen im Terminal
        if time.ticks_diff(time.ticks_ms(), last_heartbeat) > 3000:
            print(f"[Live] Score: {score*100:.1f}% | Index: {current_idx}")
            last_heartbeat = time.ticks_ms()

        # Kernlogik: Threshold überschritten UND neuer Index
        if score > cfg.GESTURE_THRESHOLD:
            if current_idx != last_label_idx:
                label_name = cfg.LABELS[current_idx] if current_idx < len(cfg.LABELS) else "Unknown"
                print(f"--- GESTE: {label_name} (Index {current_idx}) mit {score*100:.1f}% ---")
                
                # Update des letzten Index, um Mehrfachausgabe zu verhindern
                last_label_idx = current_idx
        else:
            # Reset der Sperre, sobald man unter den Threshold fällt.
            # Erlaubt es, dieselbe Geste nach einer kurzen Pause erneut zu triggern.
            last_label_idx = -1

    # --- Timing-Steuerung (konstante 50Hz Frequenz) ---
    sample_time_ms = int(cfg.SAMPLE_TIME * 1000)
    next_tick = time.ticks_add(next_tick, sample_time_ms)
    
    sleep_duration = time.ticks_diff(next_tick, time.ticks_ms())
    if sleep_duration > 0:
        time.sleep_ms(sleep_duration)
    else:
        # Falls die Verarbeitung zu lange dauert, Zeitstempel synchronisieren
        next_tick = time.ticks_ms()